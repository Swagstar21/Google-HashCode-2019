import java.io.File; 
import java.io.FileNotFoundException;
import java.io.PrintWriter;
import java.io.UnsupportedEncodingException;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Scanner;

public class main {
	static int nrPoze; // number of pictures
	static ArrayList<HashSet<String>> tagPoze; // the list of tags each picture has
	static char[] tipPoze; // vertical or horizontal
	static int[] idPoze; // if a picture is vertical it will be paired with a specific picture
	static ArrayList<Integer> pozaFolosita; // to determine if a picture was already included
	static int nr;
	
	// function that determines the score generated by two consecutive pictures
	public static int minScore(HashSet<String> a, HashSet<String> b) {
		int common = 0;
		int diffA = 0;
		int diffB = 0;

		Iterator<String> iterator = a.iterator();
		// determines the number of tags they have in common and the number of differences
		while(iterator.hasNext()) {
			if (b.contains(iterator.next()))
				common++;
			else diffA++;
		}

		iterator = b.iterator();
		// the other difference
		while(iterator.hasNext()) {
			if (!a.contains(iterator.next()))
				diffB++;
		}
		// returns the minimum between the 3
		return Math.min(common, Math.min(diffA, diffB));
	}

	// each vertical picture is paired with the next vertical picture available
	public static void groupVertical() {
		int gasita = -1;
		for (int i = 0; i < tagPoze.size(); i++) {
			if (tipPoze[i] == 'H' || pozaFolosita.get(i) == 1)
				continue;
			else {
				if (gasita == -1) // if it is the first one in a pair we mark it
					gasita = i;
				else { // if it is the second one we pair them together and scratch off the last one
					Iterator<String> iterator = tagPoze.get(i).iterator();
					while (iterator.hasNext()) {
						tagPoze.get(gasita).add(iterator.next());
					}
					tipPoze[gasita] = 'V';
					idPoze[gasita] = i;
					gasita = -1;
					pozaFolosita.set(i, 1);
					nr++;
				}
			}
		}
		if(gasita !=-1)
			{
			pozaFolosita.set(gasita, 1);
			nr++;
			}
		}
	
	
	public static void main(String[] args) {
		// opening the input file
		Scanner sc = null;
		File file = new File("b_lovely_landscapes.txt"); 
		 try {
			 sc = new Scanner(file);
		} 
		 catch (FileNotFoundException e)
		 {	
			
		} 
		// initialisations
		 sc.useDelimiter("\\Z");
		 String [] splited = sc.next().toString().split("\n");
		 
		 nrPoze  = Integer.parseInt(splited[0]);
		 if(nrPoze > 10000)
			 nrPoze = 10000;
		 tipPoze = new char[nrPoze];
		 tagPoze = new ArrayList <>(); 
		 idPoze = new int[nrPoze];
		 pozaFolosita = new ArrayList<Integer>();
		 
		 // extract the information from the input file
		 for(int i = 1; i <= nrPoze; i++)
		 {	 idPoze[i-1] = i-1;
			 HashSet<String> poza = new HashSet<String>();
			 tipPoze[i-1] = splited[i].charAt(0);
			 String x = splited[i].substring(4, splited[i].length());
			 String[] tags = x.split(" ");
			 for(int j = 0; j < tags.length;j++) 
				 poza.add(tags[j]);
			 pozaFolosita.add(0);
			 tagPoze.add(poza);
			 
		 }
		
		// group the vertical pictures
		 groupVertical();
		 
		 // we consider each picture as a node from a graph
		 // and try to find the longest route through it that
		 // traverses a node only once
		 int[][] matAdiacenta =  new int[nrPoze][nrPoze];
		 for( int i = 0; i<nrPoze; i++)
		 { 
			 for(int j = 0; j<nrPoze; j++)
			 {  
				if(i==j || pozaFolosita.get(j)==1 || pozaFolosita.get(i)== 1) 
					matAdiacenta[i][j]=-1;
				else
				{
					matAdiacenta[i][j] = minScore(tagPoze.get(i),tagPoze.get(j));
					
				}
			 }	 
		 }
		 
		 // determining the longest road
		int lungMaxim = -1;
		ArrayList<Integer> drumMaxim = null;
		 // starting from the kth node 
		for(int k = 0; k < 3; k++)
		{
			// determining the maximum for this starting node
			int lungLocal = 0;
			ArrayList<Integer> drumLocal = new ArrayList<Integer>();
			int[] trecut = new int[nrPoze];
			
			if(pozaFolosita.get(k)==1)
				continue;
			
			trecut[k] = 1;
			drumLocal.add(k);
			// traversal of the graph by following the longest available edge
			for(int i = 1; i < pozaFolosita.size();i++) {
				int max = -1;
				int index = -1;
				// finding the longest edge
				for (int j = 0; j < pozaFolosita.size(); j++) {
					if (pozaFolosita.get(j) == 1 || trecut[j] == 1) {
						continue;
					}
					else {
						int x = drumLocal.get(drumLocal.size() - 1);
						if (max < matAdiacenta[x][j]) {
							max = matAdiacenta[x][j];
							index = j;
						}
					}
						
				}
				// constructing the road
				if (max == -1)
					break;
				drumLocal.add(index);
				trecut[index] = 1;
				lungLocal += max;
			}
			// update the longest road if needed
			if (lungLocal > lungMaxim) {
				lungMaxim = lungLocal;
				drumMaxim = drumLocal;
			}
		}
		 
		// printing the longest route and its length
		PrintWriter writer = null;
		try {
			writer = new PrintWriter("B-Example.txt", "UTF-8");
		} catch (FileNotFoundException e) {
			e.printStackTrace();
		} catch (UnsupportedEncodingException e) {
			e.printStackTrace();
		}
		writer.println(nrPoze-nr);
		for (int i = 0; i < drumMaxim.size(); i++) {
			writer.print(drumMaxim.get(i));
			if (idPoze[drumMaxim.get(i)] != drumMaxim.get(i))
				writer.print(" "+idPoze[drumMaxim.get(i)]);
			writer.println();
		}
		writer.close();
		
		
	}

}
